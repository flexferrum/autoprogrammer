{% macro ProcessTypedMember(type, macroPrefix, extraVal) %}
	{% if type.type.isNoType %}
	{% elif type.type.isBuiltinType %}
	// invoke {{ macroPrefix + 'BuiltinType' }}
	{{ extraVal | applymacro(macro=macroPrefix + 'BuiltinType', type ) }}
	{% elif type.type.isRecordType %}
	// invoke {{ macroPrefix + 'RecordType' }}
	{{ extraVal | applymacro(macro=macroPrefix + 'RecordType', type ) }}
	{% elif type.type.isTemplateType %}
	// invoke {{ macroPrefix + 'TemplateType' }}
	{{ extraVal | applymacro(macro=macroPrefix + 'TemplateType', type ) }}
	{% elif type.type.isWellKnownType %}
	// invoke {{ macroPrefix + 'WellKnownType' }}
	{{ extraVal | applymacro(macro=macroPrefix + 'WellKnownType', type ) }}
	{% elif type.type.isArrayType %}
	// invoke {{ macroPrefix + 'ArrayType' }}
	{{ extraVal | applymacro(macro=macroPrefix + 'ArrayType', type, type.type.dims, type.type.itemType ) }}
	{% elif type.type.isEnumType %}
	// invoke {{ macroPrefix + 'EnumType' }}
	{{ extraVal | applymacro(macro=macroPrefix + 'EnumType', type ) }}
	{% else %}
	// invoke {{ macroPrefix + 'GenericType' }}
	{{ extraVal | applymacro(macro=macroPrefix + 'GenericType', type) }}
	{% endif %}
{% endmacro %}

{% macro SerializeBuiltinType(valueRef, typeInfo) %}
value = {{ valueRef }};
{% endmacro %}

{% macro SerializeWellKnownType(valueRef, typeInfo) %}
	{% if typeInfo.type.type == 'StdString' %}
		const auto& str = {{ valueRef }};
		value.SetString(StringRef(str.data(), str.size()));
	{% elif typeInfo.type.type == 'StdVector' or typeInfo.type.type == 'StdArray' or typeInfo.type.type == 'StdList' or typeInfo.type.type == 'StdSet' %}
		value.SetArray();
		for (auto& v : {{ valueRef }})
		{		
			auto& array = value;
			Value value;
			{{ typeInfo.type.arguments[0] | applymacro(macro='ProcessTypedMember', 'Serialize', 'v') }}
			array.PushBack(value.Move(), allocator);
		}
	{% else %}
	// Make handler for well-known type {{ typeInfo.type.type }}
	{% endif %}
{% endmacro %}

{% macro SerializeEnumType(valueRef) %}
	JsonSerialize(value, {{ valueRef }}, allocator);
{% endmacro %}

{% macro SerializeRecordType(valueRef) %}
	JsonSerialize(value, {{ valueRef }}, allocator);
{% endmacro %}

{% extends "header_skeleton.j2tpl" %}
{% block generator_headers %}
 #include <rapidjson/Document.h>
 #include <rapidjson/rapidjson.h>
 #include <algorithm>
 #include <utility>
{% endblock %}

{% block namespaced_decls %}{{super()}}{% endblock %}

{# % block namespace_content %}
{% for enum in ns.enums | sort(attribute="name") %}
{% set enumName = enum.name %}
{% set scopeSpec = enum.scopeSpecifier %}
{% set scopedName = scopeSpec ~ ('::' if scopeSpec) ~ enumName %}
{% set prefix = (scopedName + '::') if not enumInfo.isScoped else (scopedName ~ '::' ~ scopeSpec ~ ('::' if scopeSpec)) %}

inline const char* {{enumName}}ToString({{scopedName}} e)
{
    switch (e)
    {
{% for itemName in enum.items | map(attribute="itemName") | sort%}
    case {{prefix}}{{itemName}}:
        return "{{itemName}}";
{% endfor %}
    }
    return "Unknown Item";
}

inline {{scopedName}} StringTo{{enumName}}(const char* itemName)
{
    static std::pair<const char*, {{scopedName}}> items[] = {
{% for itemName in enum.items | map(attribute="itemName") | sort %}
        {"{{itemName}}", {{prefix}}{{itemName}} } {{',' if not loop.last }}
{% endfor %}
    };

    auto p = std::lower_bound(begin(items), end(items), itemName,
                      [](auto&& i, auto&& v) {return strcmp(i.first, v) < 0;});
    
    if (p == end(items) || strcmp(p->first, itemName) != 0)
        throw std::invalid_argument(std::string("Bad {{scopedName}} enum item name: ") + itemName);
    
    return p->second;
}
{% endfor %}{% endblock % #}

{% macro SerializeBuitinType(m, t) %}
	node.AddMember("{{ m.name }}", value.{{ m.name }}, allocator);
{% endmacro %}

{% block global_decls %}
{% for ns in [rootNamespace] recursive %}
#if 0
{{ ns | pprint }}
#endif
{% for enum in ns.enums %}
{% set enumName = enum.name %}
{% set scopeSpec = enum.scopeSpecifier %}
{% set scopedName = scopeSpec ~ ('::' if scopeSpec) ~ enumName %}
{% set prefix = (scopedName + '::') if not enumInfo.isScoped else (scopedName ~ '::' ~ scopeSpec ~ ('::' if scopeSpec)) %}
void JsonSerialize(rapidjson::Value& node, {{ enum.fullQualifiedName }} value, rapidjson::Document::AllocatorType& allocator)
{
    switch (value)
    {
{% for itemName in enum.items | map(attribute="itemName") | sort %}
    case {{prefix}}{{itemName}}:
        node.SetString("{{ itemName }}", allocator);
		break;
{% endfor %}
    }
}
{% endfor %}
{% for s in ns.classes %}
void JsonSerialize(rapidjson::Value& node, {{ s.fullQualifiedName }}& structValue, rapidjson::Document::AllocatorType& allocator)
{
	using namespace rapidjson;

	node.SetObject();
	{% for m in s.members %}
	{
		Value value;
		{{ m.type | applymacro(macro='ProcessTypedMember', 'Serialize', 'structValue.' + m.name) }}
		node.AddMember("{{ m.name }}", value.Move(), allocator);
	}
	{% endfor %}
}
{% endfor %}
{{loop(ns.innerNamespaces)}}
{% endfor %}
{% endblock %}

